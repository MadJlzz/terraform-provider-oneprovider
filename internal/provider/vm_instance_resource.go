package provider

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/MadJlzz/terraform-provider-oneprovider/pkg/common"
	"github.com/MadJlzz/terraform-provider-oneprovider/pkg/oneprovider/vm"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
)

var (
	_ resource.ResourceWithConfigure = &vmInstanceResource{}
)

type vmInstanceResource struct {
	resourceServiceInjector
}

type vmInstanceResourceModel struct {
	ID             types.String `tfsdk:"id"`
	LocationId     types.String `tfsdk:"location_id"`
	InstanceSizeId types.String `tfsdk:"instance_size_id"`
	TemplateId     types.String `tfsdk:"template_id"`
	Hostname       types.String `tfsdk:"hostname"`
	IPAddress      types.String `tfsdk:"ip_address"`
	Password       types.String `tfsdk:"password"`
	SshKeys        types.List   `tfsdk:"ssh_keys"`
}

func NewVmInstanceResource() resource.Resource {
	return &vmInstanceResource{}
}

func (r *vmInstanceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_vm_instance"
}

func (r *vmInstanceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description:         "Create a new VM instance.",
		MarkdownDescription: "Create a new VM instance.",
		Attributes: map[string]schema.Attribute{
			// Inputs
			"location_id": schema.StringAttribute{
				Description: "Location ID referencing where the VM instance will be created",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"instance_size_id": schema.StringAttribute{
				Description: "Instance size ID referencing the hardware specs of the VM instance",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"template_id": schema.StringAttribute{
				Description: "Template ID referencing the OS to use for that VM instance",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"hostname": schema.StringAttribute{
				Description: "Hostname of the VM instance",
				Required:    true,
			},
			"ssh_keys": schema.ListAttribute{
				Description: "List of SSH keys UUID to add to the VM instance. Note: The OneProvider API does not return SSH key information, so the state reflects the configured values rather than the actual server state.",
				ElementType: types.StringType,
				// Schema Using Attribute Default must be computed when using default.
				Computed: true,
				Optional: true,
				Default: listdefault.StaticValue(
					types.ListValueMust(
						types.StringType,
						[]attr.Value{},
					),
				),
			},
			// Outputs
			"id": schema.StringAttribute{
				Description: "ID of the VM instance. Generated by the provider.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ip_address": schema.StringAttribute{
				Description: "IP address of the VM instance",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"password": schema.StringAttribute{
				Description: "Password of the root user",
				Computed:    true,
				Sensitive:   true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

func (r *vmInstanceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *vmInstanceResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	locationId, _ := strconv.Atoi(data.LocationId.ValueString())
	instanceSizeId, _ := strconv.Atoi(data.InstanceSizeId.ValueString())

	var sshKeys []string
	resp.Diagnostics.Append(data.SshKeys.ElementsAs(ctx, &sshKeys, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createRequest := &vm.InstanceCreateRequest{
		LocationId:     locationId,
		InstanceSizeId: instanceSizeId,
		TemplateId:     data.TemplateId.ValueString(),
		Hostname:       data.Hostname.ValueString(),
		SshKeys:        sshKeys,
	}
	vmInstance, err := r.svc.VM.CreateInstance(ctx, createRequest)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to create resource",
			"An unexpected error occurred while attempting to create the resource."+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				err.Error(),
		)
		return
	}

	err = retry.RetryContext(ctx, time.Duration(2)*time.Minute, func() *retry.RetryError {
		info, infoErr := r.svc.VM.GetInstanceByID(ctx, vmInstance.Response.Id)
		if infoErr != nil {
			return retry.NonRetryableError(infoErr)
		}
		if info.Response.ServerInstall || strings.ToLower(info.Response.ServerState.State) == "offline" {
			return retry.RetryableError(fmt.Errorf("vm instance not ready yet"))
		}
		if info.Response.ServerInfo.IpAddress == "" {
			// This should never been happening because when I do the create - I get an IP back.
			// The fact that from the GET endpoint, there is some cases where ServerInfo.* is filled with empty
			// values means that something is wrong in their backend.
			return retry.RetryableError(fmt.Errorf("getInstance returned empty informations"))
		}
		return nil
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to refresh resource",
			"An unexpected error occurred while attempting to refresh the resource."+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				err.Error(),
		)
		return
	}

	// Set the value for computed attributes.
	data.ID = types.StringValue(vmInstance.Response.Id)
	data.IPAddress = types.StringValue(vmInstance.Response.IpAddress)
	data.Password = types.StringValue(vmInstance.Response.Password)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *vmInstanceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *vmInstanceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	info, err := r.svc.VM.GetInstanceByID(ctx, data.ID.ValueString())
	if err != nil {
		if errors.Is(err, common.ErrVmNotFound) {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError(
			"Unable to refresh resource",
			"An unexpected error occurred while attempting to refresh the resource."+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				err.Error(),
		)
		return
	}

	// TODO: It seems we need to do other calls to replace the names by their ID... (e.g city)
	data.Hostname = types.StringValue(info.Response.ServerInfo.Hostname)
	data.IPAddress = types.StringValue(info.Response.ServerInfo.IpAddress)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *vmInstanceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var state *vmInstanceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	var plan *vmInstanceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	// We are updating the hostname...
	if state.Hostname != plan.Hostname {
		updateRequest := &vm.InstanceHostnameUpdateRequest{
			VmId:     plan.ID.ValueString(),
			Hostname: plan.Hostname.ValueString(),
		}

		err := r.svc.VM.UpdateInstanceHostname(ctx, updateRequest)
		if err != nil {
			resp.Diagnostics.AddError(
				"Unable to update resource",
				"An unexpected error occurred while attempting to update the resource."+
					"Please retry the operation or report this issue to the provider developers.\n\n"+
					err.Error(),
			)
			return
		}

		err = retry.RetryContext(ctx, time.Duration(30)*time.Second, func() *retry.RetryError {
			info, infoErr := r.svc.VM.GetInstanceByID(ctx, plan.ID.ValueString())
			if infoErr != nil {
				return retry.NonRetryableError(infoErr)
			}
			if info.Response.ServerInfo.Hostname != plan.Hostname.ValueString() {
				return retry.RetryableError(fmt.Errorf("vm instance hostname not updated yet"))
			}
			return nil
		})
		if err != nil {
			resp.Diagnostics.AddError(
				"Unable to refresh resource after update",
				"The update succeeded but failed to refresh the resource state."+
					"Please retry the operation or report this issue to the provider developers.\n\n"+
					err.Error(),
			)
			return
		}
		plan.Hostname = types.StringValue(updateRequest.Hostname)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

func (r *vmInstanceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *vmInstanceResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	destroyRequest := &vm.InstanceDestroyRequest{
		VmId:         data.ID.ValueString(),
		ConfirmClose: true,
	}

	err := r.svc.VM.DestroyInstance(ctx, destroyRequest)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to destroy resource",
			"An unexpected error occurred while attempting to destroy the resource."+
				"Please retry the operation or report this issue to the provider developers.\n\n"+
				err.Error(),
		)
		return
	}
}
